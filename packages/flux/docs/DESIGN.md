# @fukict/flux 设计文档

## 包职责

flux 是 Fukict 的极简状态管理库，核心理念是 **Flux 自身无更新权限，仅提供订阅机制**。

职责定位：

1. **状态存储**：集中式应用状态容器
2. **订阅通知**：状态变化时通知订阅者
3. **状态读取**：提供当前状态快照
4. **状态更新接口**：暴露更新方法，但由外部 Actions 调用

**非职责**（刻意不做）：

- ❌ 不提供内置的 Actions/Reducers（由用户在外部定义）
- ❌ 不提供异步处理机制（由 Actions 层自行处理）
- ❌ 不强制不可变更新（信任用户，性能优先）
- ❌ 不提供全局单例（每个模块独立创建）

## 核心设计原则

### 1. 职责分离

**Flux 层**：负责状态存储、订阅管理
**Actions 层**：负责业务逻辑、状态更新

```
┌─────────────────────────────────────┐
│          Component Layer            │
│  (订阅状态变化，调用 Actions)          │
└────────────┬────────────────────────┘
             │ subscribe / call actions
             ↓
┌─────────────────────────────────────┐
│          Actions Layer              │
│  (业务逻辑，调用 setState)            │
└────────────┬────────────────────────┘
             │ setState
             ↓
┌─────────────────────────────────────┐
│           Flux Layer                │
│  (状态存储，通知订阅者)                │
└─────────────────────────────────────┘
```

### 2. 单向数据流

状态更新流程：

1. 用户操作 → 调用 Action
2. Action 读取当前状态（getState）
3. Action 计算新状态并更新（setState）
4. Flux 通知所有订阅者
5. 组件收到通知，触发重新渲染

### 3. 最小化 API

只提供三个核心能力：

- **读取状态**：`getState()`
- **更新状态**：`setState()`
- **订阅变化**：`subscribe()` / 返回取消订阅函数

### 4. 模块化设计

每个业务模块独立创建自己的 Flux 实例，避免全局状态污染：

```
App
├── userFlux (用户状态)
├── cartFlux (购物车状态)
└── uiFlux (UI 状态)
```

## 使用模式

### 基础模式：手动创建 Flux + Actions

**适用场景**：简单状态、快速原型

**设计思路**：

- 直接实例化 Flux 类
- 在外部定义 Actions 对象
- Actions 直接调用 `flux.setState()`

**优点**：灵活、直接、易理解
**缺点**：需要手动管理 Flux 实例和 Actions 的关联

### 工厂模式：createFlux（推荐）

**适用场景**：模块化应用、需要类型安全

**设计思路**：

- 使用工厂函数封装 Flux 创建过程
- Actions 定义在配置对象中，自动绑定到 Flux 实例
- 返回统一的接口对象，包含 flux、actions、快捷方法

**优点**：

1. API 统一，使用方便
2. 类型推导完整
3. Actions 和 Flux 绑定清晰
4. 支持模块化导出

**缺点**：增加一层抽象

### 选择器模式：局部订阅

**适用场景**：大型状态树、性能优化

**设计思路**：

- 订阅时提供选择器函数，只选择需要的状态片段
- Flux 比较选择器的返回值，只在变化时通知
- 避免不相关状态变化触发不必要的渲染

**优点**：性能优化、减少渲染
**缺点**：需要额外的比较逻辑

## 状态更新策略

### 完整更新 vs 部分更新

**完整更新**：`setState(newState)`

- 完全替换状态对象
- 适用于小型状态

**部分更新**：`setState(partialState)`

- 浅合并到当前状态
- 适用于大型状态树

### 不可变性建议（非强制）

虽然不强制不可变更新，但建议遵循：

1. **对象更新**：使用展开运算符 `{ ...state, key: value }`
2. **数组更新**：使用非变异方法（map、filter、concat）
3. **嵌套更新**：逐层展开

**原因**：

- 便于调试和追踪
- 更容易实现时间旅行
- 避免引用问题导致的 bug

## 订阅机制设计

### 订阅生命周期

1. **订阅**：`subscribe(listener)` 返回取消函数
2. **通知**：`setState()` 触发所有 listener
3. **取消订阅**：调用返回的函数

### 订阅时机

**组件层**：

- `mounted()` 中订阅
- `beforeUnmount()` 中取消订阅

**避免**：

- 不在 `render()` 中订阅（每次渲染都会重复订阅）
- 不忘记取消订阅（内存泄漏）

### 选择器订阅

**设计目标**：避免无关状态变化触发渲染

**工作原理**：

1. 用户提供选择器函数：`(state) => state.user`
2. Flux 记录上次选择器的返回值
3. 状态更新时，重新执行选择器
4. 比较新旧值（浅比较），仅在变化时通知

**适用场景**：

- 大型状态树（如整个应用状态）
- 组件只关心部分状态（如只需要 user 不需要 cart）

## 与 Fukict 框架集成

### 触发渲染

Flux 不直接操作 DOM，而是通过 Fukict 的更新机制：

1. 组件订阅 Flux 状态
2. 状态变化时，listener 调用 `this.update()`
3. Fukict 的 diff 算法处理实际 DOM 更新

### 生命周期集成

- **mounted**：订阅状态，获取初始数据
- **beforeUnmount**：取消订阅，清理资源
- **render**：读取状态快照（getState），不订阅

### 订阅位置最佳实践

**重要**：Fukict 的 VNode 更新是**自上而下**传播的，`this.update()` 会触发当前组件及其所有子组件的重新渲染。因此订阅位置的选择直接影响性能。

#### 原则 1：在组件树的最上层订阅

**推荐**：在根组件或布局组件订阅全局状态

```
App (订阅 globalFlux) ✅
├── Header (读取状态，不订阅)
├── Sidebar (读取状态，不订阅)
└── Content (读取状态，不订阅)
```

**原因**：

- 一次 update 触发，整个树重新渲染
- 避免多个组件重复订阅
- 减少订阅管理成本

#### 原则 2：相同层级不同组件各自订阅

**推荐**：兄弟组件订阅不同的 Flux 模块

```
App
├── UserPanel (订阅 userFlux) ✅
├── CartPanel (订阅 cartFlux) ✅
└── NotificationPanel (订阅 notificationFlux) ✅
```

**原因**：

- 状态隔离，互不影响
- 用户状态变化不会触发购物车重新渲染
- 每个组件只关心自己的状态

#### 原则 3：使用 `fukict:detach` 脱围后自行订阅

**推荐**：脱围组件（detach）自己订阅状态

```
App (订阅 globalFlux)
├── StaticHeader (fukict:detach, 订阅 userFlux) ✅
├── DynamicContent (读取 globalFlux)
└── StaticFooter (fukict:detach, 订阅 settingsFlux) ✅
```

**原因**：

- `fukict:detach` 让组件脱离父组件的更新链
- 父组件 update 不会触发脱围组件的渲染
- 脱围组件需要自己订阅状态，手动触发 update

**使用场景**：

- Header/Footer（很少变化，不需要跟随父组件更新）
- 独立的弹窗/对话框
- 性能敏感的组件（如编辑器）

#### 反模式：避免深层嵌套的重复订阅

**❌ 不推荐**：父子组件都订阅同一状态

```
App (订阅 userFlux) ❌
└── UserProfile (订阅 userFlux) ❌
    └── UserAvatar (订阅 userFlux) ❌
```

**问题**：

- 状态变化时，三个组件都触发 update
- App update 会导致 UserProfile 和 UserAvatar 重新渲染
- UserProfile update 会导致 UserAvatar 重新渲染
- UserAvatar update 自己再次渲染
- **同一次状态变化，导致多次重复渲染**

**改进方案**：只在 App 订阅

```
App (订阅 userFlux) ✅
└── UserProfile (读取状态，不订阅)
    └── UserAvatar (读取状态，不订阅)
```

#### 特殊场景：局部状态订阅

如果子组件确实需要独立响应状态变化（不依赖父组件），考虑：

1. **使用脱围 + 订阅**：

```typescript
class IndependentWidget extends Fukict {
  // props 中传入 fukict:detach
  mounted() {
    this.unsubscribe = widgetFlux.subscribe(() => {
      this.update();  // 只更新自己，不影响父组件
    });
  }
}

// 使用时
<IndependentWidget fukict:detach={true} />
```

2. **拆分 Flux 模块**：

```typescript
// 父组件订阅 parentFlux
// 子组件订阅 childFlux
// 两个状态互不干扰
```

### 性能考虑

- **批量更新**：多次 setState 可以合并通知（可选优化）
- **选择器订阅**：避免不必要的组件更新
- **状态分割**：按模块拆分 Flux 实例，减小状态树
- **订阅位置**：遵循上述最佳实践，避免重复渲染

### 订阅位置决策树

```
需要订阅状态？
├─ 是
│  ├─ 是全局状态？
│  │  ├─ 是 → 在根组件/布局组件订阅
│  │  └─ 否 → 继续判断
│  │
│  ├─ 是否与兄弟组件共享状态？
│  │  ├─ 是 → 在共同的父组件订阅
│  │  └─ 否 → 各自订阅独立的 Flux 模块
│  │
│  └─ 是否需要脱离父组件更新？
│     ├─ 是 → 使用 fukict:detach + 自行订阅
│     └─ 否 → 依赖父组件的订阅，自己只读取状态
│
└─ 否 → 直接读取状态（getState），不订阅
```

## 扩展性设计

### 中间件（可选功能）

**设计目标**：在不修改核心的前提下，增加额外能力

**触发时机**：每次 `setState()` 前后

**应用场景**：

- 日志记录（记录状态变化历史）
- 开发工具集成（Redux DevTools）
- 性能监控（统计更新耗时）
- 持久化（自动保存到 localStorage）

**设计原则**：

- 中间件可选，默认不开启
- 不影响核心性能
- 用户可以自定义中间件

### 时间旅行（可选功能）

**设计目标**：支持撤销/重做

**实现思路**：

1. 中间件记录每次状态变化历史
2. 提供 `undo()` / `redo()` 方法
3. 跳转到历史状态时，触发订阅者

**适用场景**：

- 编辑器应用
- 表单应用
- 调试工具

## 类型安全

### TypeScript 支持

**设计目标**：完整的类型推导，无需手动标注

**类型层级**：

```
State Type (T)
  ↓
Flux<T>
  ↓
Actions (自动推导)
  ↓
Component (使用时自动提示)
```

### 类型推导要求

1. **状态类型**：从初始值自动推导
2. **Actions 返回类型**：自动推导，无需标注
3. **订阅 listener**：参数类型自动推导
4. **选择器**：返回值类型自动推导

## 测试策略

### 单元测试

**测试对象**：Flux 核心功能

- 状态初始化
- setState 更新
- subscribe 订阅通知
- 选择器订阅（仅在变化时通知）
- 取消订阅

**测试原则**：

- 不依赖 Fukict 框架
- 纯函数测试
- 边界条件覆盖

### 集成测试

**测试对象**：Flux + Actions + Component

- Actions 调用 setState
- 组件订阅并触发更新
- 多组件订阅同一状态
- 组件卸载后取消订阅

## 与其他状态管理方案对比

### vs Redux

**相同点**：

- 单向数据流
- 集中式状态管理
- 可预测的状态更新

**不同点**：

- Flux：Actions 在外部，无固定模式（更灵活）
- Redux：强制 Reducer 模式，不可变更新（更严格）
- Flux：无中间件内置（可选）
- Redux：中间件生态丰富（如 redux-thunk）

**适用场景**：

- Flux：轻量级应用、快速开发、性能敏感
- Redux：大型应用、团队协作、严格约束

### vs MobX

**相同点**：

- 响应式更新
- 自动通知订阅者

**不同点**：

- Flux：手动订阅/取消订阅（显式）
- MobX：自动追踪依赖（隐式）
- Flux：浅层监听
- MobX：深层响应式

**适用场景**：

- Flux：可控性强、调试清晰
- MobX：开发效率高、自动优化

### vs Zustand

**相同点**：

- 极简 API
- 无样板代码
- 模块化设计

**不同点**：

- Flux：Fukict 框架专用，与生命周期深度集成
- Zustand：框架无关，React/Vue 通用
- Flux：createFlux 工厂模式
- Zustand：create 函数 + hooks

**适用场景**：

- Flux：Fukict 应用专用
- Zustand：通用轻量级方案

## 未来演进方向

### 短期（v1.0）

- 核心 Flux 类实现
- createFlux 工厂函数
- 选择器订阅
- 完整的 TypeScript 类型

### 中期（v1.x）

- 中间件系统
- 开发工具集成（DevTools）
- 性能优化（批量更新）
- 持久化插件

### 长期（v2.0）

- 时间旅行调试
- 状态快照/恢复
- 异步 Actions 辅助工具
- 性能分析工具

## 设计决策记录

### 为什么 Flux 自身无更新权限？

**决策**：Flux 只提供 setState 接口，不内置 Actions

**原因**：

1. **职责分离**：状态管理和业务逻辑解耦
2. **灵活性**：用户可以自由组织 Actions（函数/类/对象）
3. **可测试性**：Actions 可以独立测试，不依赖 Flux
4. **轻量级**：核心代码最小化，不强加模式

### 为什么不强制不可变更新？

**决策**：建议但不强制

**原因**：

1. **性能**：避免深拷贝开销
2. **灵活性**：简单场景可以直接修改
3. **学习成本**：降低上手难度
4. **信任用户**：用户知道自己在做什么

**风险控制**：

- 文档中强调最佳实践
- 提供工具检测变异（可选）

### 为什么选择工厂函数而非类继承？

**决策**：推荐 createFlux 工厂函数，而非 `class MyFlux extends Flux`

**原因**：

1. **组合优于继承**：工厂函数更灵活
2. **类型推导**：函数返回值类型推导更友好
3. **简洁性**：减少样板代码
4. **模块化**：每个模块独立导出

### 为什么不提供全局单例？

**决策**：每个模块独立创建 Flux 实例

**原因**：

1. **模块隔离**：避免全局状态污染
2. **可测试性**：每个测试独立实例
3. **服务端渲染**：每个请求独立状态
4. **灵活性**：用户可以自己决定是否全局

**用户可以自己实现全局单例**：

```typescript
// store/index.ts
export const globalStore = createFlux({ ... });
```
