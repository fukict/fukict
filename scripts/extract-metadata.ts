#!/usr/bin/env tsx
/**
 * Extract metadata from package.json for each package
 * Generates src/metadata.ts with a single METADATA constant
 * Only generates for packages with metadata: true in build.config.yml
 */
import { existsSync, mkdirSync, readFileSync, writeFileSync } from 'fs';
import { dirname, resolve } from 'path';
import { fileURLToPath } from 'url';

import { getAvailablePackages, getPackageConfig } from './utils.js';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

const colors = {
  reset: '\x1b[0m',
  red: '\x1b[31m',
  green: '\x1b[32m',
  yellow: '\x1b[33m',
  blue: '\x1b[34m',
  cyan: '\x1b[36m',
};

function log(color: keyof typeof colors, message: string): void {
  console.log(`${colors[color]}${message}${colors.reset}`);
}

interface PackageJson {
  name: string;
  version: string;
  description?: string;
  author?: string;
  license?: string;
  homepage?: string;
  repository?: {
    type: string;
    url: string;
  };
}

interface Metadata {
  name: string;
  version: string;
  description: string;
  author: string;
  license: string;
  homepage: string;
  repository: string;
}

function extractMetadata(packageName: string): boolean {
  const packagePath = resolve(__dirname, '..', 'packages', packageName);
  const packageJsonPath = resolve(packagePath, 'package.json');
  const srcPath = resolve(packagePath, 'src');
  const metadataPath = resolve(srcPath, 'metadata.ts');

  // Read package.json
  if (!existsSync(packageJsonPath)) {
    log('red', `‚ùå Package not found: ${packageName}`);
    return false;
  }

  const packageJson: PackageJson = JSON.parse(
    readFileSync(packageJsonPath, 'utf-8'),
  ) as PackageJson;

  // Ensure src directory exists
  if (!existsSync(srcPath)) {
    mkdirSync(srcPath, { recursive: true });
  }

  // Build metadata object
  const metadata: Metadata = {
    name: packageJson.name,
    version: packageJson.version,
    description: packageJson.description || '',
    author: packageJson.author || '',
    license: packageJson.license || '',
    homepage: packageJson.homepage || '',
    repository: packageJson.repository?.url || '',
  };

  // Generate metadata content
  const metadataContent = `/**
 * Package metadata
 * Auto-generated by extract-metadata.ts - DO NOT EDIT MANUALLY
 */

export const METADATA = {
  name: '${metadata.name}',
  version: '${metadata.version}',
  description: '${metadata.description}',
  author: '${metadata.author}',
  license: '${metadata.license}',
  homepage: '${metadata.homepage}',
  repository: '${metadata.repository}',
} as const;
`;

  // Write metadata file
  writeFileSync(metadataPath, metadataContent, 'utf-8');
  log(
    'green',
    `‚úÖ Generated metadata for ${packageName}: ${packageJson.name}@${packageJson.version}`,
  );

  return true;
}

async function main(): Promise<void> {
  log('blue', 'üì¶ Extracting metadata from packages...\n');

  const packages = getAvailablePackages();
  const failedPackages: string[] = [];
  const skippedPackages: string[] = [];

  for (const pkg of packages) {
    const config = getPackageConfig(pkg);

    // Check if metadata generation is enabled for this package
    if (!config || config.metadata !== true) {
      log('yellow', `‚è≠Ô∏è  Skipped ${pkg}: metadata generation disabled`);
      skippedPackages.push(pkg);
      continue;
    }

    const success = extractMetadata(pkg);
    if (!success) {
      failedPackages.push(pkg);
    }
  }

  console.log('');

  if (failedPackages.length > 0) {
    log('red', `‚ùå Failed to extract metadata: ${failedPackages.join(', ')}`);
    process.exit(1);
  } else {
    const generatedCount = packages.length - skippedPackages.length;
    if (generatedCount > 0) {
      log(
        'green',
        `‚úÖ Successfully extracted metadata for ${generatedCount} package(s)`,
      );
    }
    if (skippedPackages.length > 0) {
      log(
        'cyan',
        `‚ÑπÔ∏è  Skipped ${skippedPackages.length} package(s): ${skippedPackages.join(', ')}`,
      );
    }
  }
}

main().catch((error: unknown) => {
  const errorMessage =
    error instanceof Error ? error.message : String(error || 'Unknown error');
  log('red', `‚ùå Error: ${errorMessage}`);
  process.exit(1);
});
