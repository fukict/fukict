# Fukict 重构 TODO

## 阶段一：架构设计

### 1. 核心设计文档
- [ ] 1.1 设计 runtime 注册机制（核心中的核心）
  - [ ] 组件渲染钩子注册接口设计
  - [ ] 生命周期钩子注册接口设计
  - [ ] 数组节点渲染钩子注册接口设计
  - [ ] 脱围渲染钩子注册接口设计
  - [ ] 钩子优先级和执行顺序设计

- [ ] 1.2 runtime 包能力边界设计
  - [ ] 内置能力：VNode 创建、DOM 操作、基础渲染
  - [ ] 开放能力：注册机制接口定义
  - [ ] 包导出策略（什么暴露、什么隐藏）

- [ ] 1.3 widget 包能力边界设计
  - [ ] 如何通过注册机制扩展 runtime
  - [ ] Widget 类组件设计（生命周期、refs、slots）
  - [ ] 函数组件设计（轻量级、无生命周期）
  - [ ] 组件挂载/卸载/更新机制
  - [ ] 数组节点渲染机制（基于 runtime 钩子）
  - [ ] 脱围渲染机制（fukict:detach）
  - [ ] 包导出策略

- [ ] 1.4 scheduler 包独立设计
  - [ ] 从 widget 剥离的理由
  - [ ] 调度策略设计（requestIdleCallback/requestAnimationFrame）
  - [ ] 优先级队列设计
  - [ ] 与 widget 的集成方式
  - [ ] 可选依赖策略

- [ ] 1.5 babel-plugin 包设计
  - [ ] JSX 编译优化策略
  - [ ] 事件分离机制（on: 前缀）
  - [ ] 静态节点优化
  - [ ] 组件类型识别

- [ ] 1.6 router 包设计
  - [ ] 路由匹配算法
  - [ ] 嵌套路由设计
  - [ ] 路由守卫机制
  - [ ] 与 widget 集成方式

- [ ] 1.7 flux 包设计
  - [ ] Store 架构设计
  - [ ] 中间件机制
  - [ ] 时间旅行调试支持
  - [ ] 与 widget 的可选集成

### 2. 包依赖关系设计
- [ ] 2.1 梳理所有包的依赖关系图
- [ ] 2.2 确定 peer dependencies 策略
- [ ] 2.3 确定包版本管理策略
- [ ] 2.4 设计用户安装和引用方式

### 3. 文档结构规划
- [ ] 3.1 根目录 docs/ 结构设计
  - [ ] 架构总览文档
  - [ ] 快速开始指南
  - [ ] 核心概念文档
  - [ ] API 索引

- [ ] 3.2 包级别 packages/*/docs/ 结构设计
  - [ ] DESIGN.md（设计文档，专注设计思路）
  - [ ] API.md（API 文档）
  - [ ] EXAMPLES.md（使用示例）
  - [ ] CHANGELOG.md（变更日志）

- [ ] 3.3 CLAUDE.md 规范更新
  - [ ] 开发工作流规范
  - [ ] 完成任务后必须更新 TODO
  - [ ] 功能边界变更必须更新文档
  - [ ] 设计决策记录规范

## 阶段二：详细设计文档编写

### 4. runtime 包详细设计
- [ ] 4.1 编写 runtime DESIGN.md
  - [ ] 注册机制详细设计
  - [ ] VNode 结构设计
  - [ ] DOM 操作抽象层设计
  - [ ] 渲染流程设计
  - [ ] 内置能力清单
  - [ ] 开放能力清单

- [ ] 4.2 编写 runtime API.md
  - [ ] hyperscript API
  - [ ] render API
  - [ ] 注册 API
  - [ ] 类型定义

### 5. widget 包详细设计
- [ ] 5.1 编写 widget DESIGN.md
  - [ ] Widget 类组件架构
  - [ ] 函数组件架构
  - [ ] Refs 机制设计
  - [ ] Slots 机制设计
  - [ ] 挂载/卸载/更新流程
  - [ ] 数组渲染机制
  - [ ] 脱围渲染机制
  - [ ] 如何注册到 runtime

- [ ] 5.2 编写 widget API.md
  - [ ] Widget 类 API
  - [ ] defineWidget API
  - [ ] 生命周期钩子
  - [ ] Refs API
  - [ ] Slots API

### 6. scheduler 包详细设计
- [ ] 6.1 编写 scheduler DESIGN.md
  - [ ] 调度策略设计
  - [ ] 优先级队列设计
  - [ ] 任务取消机制
  - [ ] 与 widget 集成方式

- [ ] 6.2 编写 scheduler API.md

### 7. 其他包设计文档
- [ ] 7.1 babel-plugin DESIGN.md
- [ ] 7.2 babel-preset-widget DESIGN.md
- [ ] 7.3 router DESIGN.md
- [ ] 7.4 flux DESIGN.md

### 8. 预留包规划文档
- [ ] 8.1 create 包规划文档
- [ ] 8.2 devtools 包规划文档

## 阶段三：核心设计评审和优化

### 9. 设计评审
- [ ] 9.1 runtime 注册机制设计评审（核心）
  - [ ] 接口是否足够灵活
  - [ ] 是否易于扩展
  - [ ] 性能影响评估
  - [ ] 类型安全性评估

- [ ] 9.2 widget 集成设计评审
  - [ ] 与 runtime 的边界是否清晰
  - [ ] 生命周期设计是否合理
  - [ ] Refs/Slots 机制是否足够强大
  - [ ] 脱围渲染是否易用

- [ ] 9.3 包依赖关系评审
  - [ ] 是否存在循环依赖
  - [ ] peer dependencies 是否合理
  - [ ] 用户使用是否简洁

- [ ] 9.4 文档完整性评审
  - [ ] 设计文档是否清晰
  - [ ] API 文档是否完整
  - [ ] 示例是否充分

### 10. 设计优化
- [ ] 10.1 根据评审结果优化 runtime 设计
- [ ] 10.2 根据评审结果优化 widget 设计
- [ ] 10.3 根据评审结果优化其他包设计
- [ ] 10.4 更新所有相关文档

## 阶段四：实施计划制定

### 11. 开发顺序规划
- [ ] 11.1 确定开发优先级
  - [ ] P0: runtime 核心 + 注册机制
  - [ ] P0: widget 基础实现
  - [ ] P1: babel-plugin
  - [ ] P1: scheduler
  - [ ] P2: router
  - [ ] P2: flux
  - [ ] P3: 预留包

- [ ] 11.2 制定里程碑
  - [ ] M1: runtime 可用（基础渲染）
  - [ ] M2: widget 可用（类组件 + 函数组件）
  - [ ] M3: 完整工具链（babel + scheduler）
  - [ ] M4: 生态完善（router + flux）

### 12. 测试策略
- [ ] 12.1 单元测试策略
- [ ] 12.2 集成测试策略
- [ ] 12.3 性能测试策略
- [ ] 12.4 类型测试策略

## 阶段五：实施（设计完成后开始）

### 13. runtime 实现
- [ ] 13.1 VNode 类型定义
- [ ] 13.2 hyperscript 实现
- [ ] 13.3 DOM 操作工具实现
- [ ] 13.4 注册机制实现（核心）
- [ ] 13.5 基础渲染流程实现
- [ ] 13.6 单元测试
- [ ] 13.7 文档更新

### 14. widget 实现
- [ ] 14.1 Widget 类基类实现
- [ ] 14.2 defineWidget 实现
- [ ] 14.3 Refs 管理实现
- [ ] 14.4 Slots 机制实现
- [ ] 14.5 注册到 runtime
- [ ] 14.6 挂载/卸载/更新实现
- [ ] 14.7 数组渲染实现
- [ ] 14.8 脱围渲染实现
- [ ] 14.9 单元测试
- [ ] 14.10 文档更新

### 15. scheduler 实现
- [ ] 15.1 调度器核心实现
- [ ] 15.2 优先级队列实现
- [ ] 15.3 任务取消实现
- [ ] 15.4 与 widget 集成
- [ ] 15.5 单元测试
- [ ] 15.6 文档更新

### 16. 其他包实现
- [ ] 16.1 babel-plugin 实现
- [ ] 16.2 babel-preset-widget 实现
- [ ] 16.3 router 实现
- [ ] 16.4 flux 实现

### 17. 集成和测试
- [ ] 17.1 创建示例项目
- [ ] 17.2 集成测试
- [ ] 17.3 性能测试
- [ ] 17.4 文档完善

## 关键设计问题（需要重点思考）

### runtime 注册机制
- 如何设计通用的钩子注册接口？
- 如何保证钩子执行顺序？
- 如何处理钩子返回值？
- 如何支持异步钩子？
- 如何避免钩子冲突？

### widget 扩展机制
- 如何通过注册机制完全控制组件渲染？
- 如何实现组件实例的生命周期管理？
- 如何实现 refs 自动注册和清理？
- 如何实现 slots 的高效提取和渲染？
- 如何实现脱围渲染（子组件不随父组件更新）？

### 数组节点渲染
- 如何注册数组节点的渲染逻辑？
- 是否需要 key 优化？如何设计？
- 如何与 widget 的 diff 机制配合？

### 包导出策略
- runtime 应该导出哪些 API？
- widget 应该重新导出哪些 runtime API？
- 如何防止用户直接使用 runtime？
- 如何保持类型完整性？

### 性能优化
- 注册机制的性能开销？
- 如何避免不必要的重渲染？
- 如何优化 diff 算法？
- 如何优化内存使用？

---

**注意事项**：
1. 每完成一个任务，立即更新此文档
2. 设计阶段不要涉及具体代码实现细节
3. 设计变更必须同步更新相关文档
4. 重点关注注册机制设计，这是整个架构的核心
